<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Variables</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"/><LINK
REL="HOME"
TITLE="ooc v0.2.1 ninja Language Reference"
HREF="book1.htm"/><LINK
REL="PREVIOUS"
TITLE="Preface"
HREF="f16.htm"/><LINK
REL="NEXT"
TITLE="Arrays"
HREF="x209.htm"/></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ooc v0.2.1 ninja Language Reference</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="f16.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x209.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"/></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN31"
></A
>Chapter 1. Variables</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c31.htm#AEN33"
>Types</A
></DT
><DT
><A
HREF="x209.htm"
>Arrays</A
></DT
><DT
><A
HREF="x223.htm"
>Pointers</A
></DT
></DL
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN33"
>Types</A
></H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN35"
>Syntax</A
></H2
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN37"
>Capitalization</A
></H3
><P
>All types should be in <TT
CLASS="literal"
>CamelCase</TT
>, all
          variables and functions in <TT
CLASS="literal"
>camelCase</TT
>. It is a
          significant difference from C and Java, for example. In ooc, an
          integer is declared as <TT
CLASS="literal"
>Int</TT
>, a boolean as
          <TT
CLASS="literal"
>Bool</TT
>, and so on.</P
><P
>The justification for that is consistency. In Java, for
          example, primitive types are in lowercase (<TT
CLASS="literal"
>int</TT
>,
          <TT
CLASS="literal"
>byte</TT
>, <TT
CLASS="literal"
>short</TT
>) and classes are
          in <TT
CLASS="literal"
>CamelCase</TT
> (<TT
CLASS="literal"
>String</TT
>,
          <TT
CLASS="literal"
>System</TT
>). There is some kind of consistency in
          this model, ie. you clearly see what is low-level and high-level.
          However, ooc takes another approach of consistency. Implementation
          details shouldn't interfere with the formatting of the source code.
          Hence, no distinction is made between an <TT
CLASS="literal"
>Int</TT
> and
          e.g. a <TT
CLASS="literal"
>MyClass</TT
>, from a user point of view.</P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN53"
>Declaration</A
></H3
><P
>A variable is declared as in Java/C:</P
><PRE
CLASS="programlisting"
>Float f;
Int i;
String s;</PRE
><P
>You can declare several variables on the same line:</P
><PRE
CLASS="programlisting"
>Float x, y, z;</PRE
><DIV
CLASS="caution"
><P
></P
><TABLE
CLASS="caution"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Caution</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Unlike C, the array-ness or pointer-ness of the type is
            valid for all the variables declared in the same line.</P
></TD
></TR
></TABLE
></DIV
><PRE
CLASS="programlisting"
>Float[256] tab1, tab2, tab3; // declares 3 arrays of 256 floats
Int* p1, p2, p3; // declares 3 pointers to ints</PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN62"
>Constants</A
></H3
><P
>Constants are declared with the const keyword:</P
><PRE
CLASS="programlisting"
>const Float EPSILON = 0.00001f;</PRE
><P
>Constants are usually implemented with
          <TT
CLASS="literal"
>#define</TT
>s<A
NAME="AEN68"
HREF="#FTN.AEN68"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>, so it's really impossible to modify one.</P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN70"
>Literals &amp; initialization</A
></H3
><P
>ooc supports the same kinds of literal as C:</P
><PRE
CLASS="programlisting"
>Int i = 3;
Short j = -43;
Double golden = 1.6180339887 + 6d; // d suffix is optional
Float = 45.0f - 3; // f suffix is optional
Char c = '3';
Char d = '\n';
String s = "Moi, j'aime p\nas les linebreaks.";</PRE
><P
>Underscores in number literals are autorhized and ignored, so
          that you can easily separate groups of digits. Strings can span over
          several lines:</P
><PRE
CLASS="programlisting"
>Int million = 1_000_000_000;
Float x = 3.14159_26535_89793f;
String quote = "Nick the Greek: Just get me a sample.
Tom: No can do.
Nick the Greek: What's that? Some place near Katmandu? Meet me halfway, mate.";</PRE
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN76"
>Types from C</A
></H2
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN78"
>Correspondance with C and Java types</A
></H3
><DIV
CLASS="table"
><A
NAME="AEN80"
></A
><P
><B
>Table 1-1. Correspondance tables of types in C, Java, and ooc.</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL/><COL/><COL/><COL/><THEAD
><TR
><TH
>C</TH
><TH
>Java</TH
><TH
>ooc</TH
><TH
>Comment</TH
></TR
></THEAD
><TBODY
><TR
><TD
>-</TD
><TD
>-</TD
><TD
>This</TD
><TD
>in a class definition, refers to the current class.
                  Really, really useful to avoid repetition.</TD
></TR
><TR
><TD
>void*</TD
><TD
>Object</TD
><TD
>Object</TD
><TD
>really just to get rid of the nasty pointer notation.
                  useful while waiting for generics</TD
></TR
><TR
><TD
>int</TD
><TD
>int</TD
><TD
>Int</TD
><TD
>often the best choice for storing numbers. use Bool
                  to store boolean values.</TD
></TR
><TR
><TD
>short</TD
><TD
>short</TD
><TD
>Short</TD
><TD
>of little use, really. use it when you have *huge*
                  arrays of numbers and tight memory.</TD
></TR
><TR
><TD
>char</TD
><TD
>char (UTF-16)</TD
><TD
>Char</TD
><TD
>use it only to store characters. for 8bit numbers,
                  see Octet</TD
></TR
><TR
><TD
>char*</TD
><TD
>String (class)</TD
><TD
>String</TD
><TD
>fully C-string compatible, unlike C++
                  strings.</TD
></TR
><TR
><TD
>uint8_t</TD
><TD
>byte</TD
><TD
>Octet</TD
><TD
>again, of little use. may be useful for storing e.g.
                  r, g, b components of a color</TD
></TR
><TR
><TD
>unsigned int</TD
><TD
>-</TD
><TD
>UInt</TD
><TD
>as in C</TD
></TR
><TR
><TD
>float</TD
><TD
>float</TD
><TD
>Float</TD
><TD
>as in C</TD
></TR
><TR
><TD
>double</TD
><TD
>-</TD
><TD
>Double</TD
><TD
>as in C</TD
></TR
><TR
><TD
>long double</TD
><TD
>-</TD
><TD
>LDouble</TD
><TD
>new in C99</TD
></TR
><TR
><TD
>long</TD
><TD
>long</TD
><TD
>Long</TD
><TD
>as in C</TD
></TR
><TR
><TD
>long long</TD
><TD
>-</TD
><TD
>LLong</TD
><TD
>new in C99</TD
></TR
><TR
><TD
>bool</TD
><TD
>boolean</TD
><TD
>Bool</TD
><TD
>uses stdbool's typedefs. You should use
                  <TT
CLASS="literal"
>true</TT
> and <TT
CLASS="literal"
>false</TT
> for
                  boolean literals, not 0 and 1.</TD
></TR
><TR
><TD
>pointer to function</TD
><TD
>hahahaha.</TD
><TD
>Func</TD
><TD
>really points to a function with no arguments
                  returning Int. more function pointer safety should be
                  introduced with generics.</TD
></TR
><TR
><TD
>size_t</TD
><TD
>-</TD
><TD
>Size</TD
><TD
>the type returned by sizeof. according to the C
                  standard, it should be used to store the 'size' of things,
                  e.g. byte count for memory-related functions (memcpy,
                  memmove)</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN172"
>Typedef (aliasing name types)</A
></H3
><P
>Typedefs exist in ooc too. They're used as in C.</P
><PRE
CLASS="programlisting"
>// This example is stupid, because it redefines the String type. It's just to show how typedefs are used.
typedef Char* String;

func main {

  String name = "princesse de slougadij";
  printf("A moins que vous n'epousiez la %s?\n", name);

}</PRE
><P
>Don't do funky stuff with typedef: it won't work. E.g.
          <TT
CLASS="literal"
>typedef struct { /* etc. */ };</TT
> If want a data
          structure, <A
HREF="c278.htm"
>define a class</A
>.</P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN179"
>Capitalization</A
></H3
><P
>If you try to declare something as 'int i', you'll be greeted
          by the compiler with the error message 'Invalid type name int. Types
          must start with an upper-case letter'. In this case, you can sort it
          out by using the ooc-ish 'Int'. But sometimes you just can't, e.g.
          with GLib types, '<TT
CLASS="literal"
>gint</TT
>',
          '<TT
CLASS="literal"
>guint</TT
>', etc. The correct handling of these cases
          is to <TT
CLASS="literal"
>typedef</TT
>' them to something
          capitalized.</P
><PRE
CLASS="programlisting"
>include glib;

typedef guint GUInt;

func main {

  GUInt myPlatformSafeInt = 69;
  gprintf("Now GLib and the ooc compilers are happy.%d\n", myPlatformSafeInt);

}</PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN186"
>Types that can't be resolved</A
></H3
><P
>Although the C header parser embedded in the ooc compiler
          really tries its best, sometimes (especially with
          <TT
CLASS="literal"
>#define</TT
>s all over the place), C types aren't
          recognized, and you have compile errors. This can be solved with the
          use of the <TT
CLASS="literal"
>ctype</TT
> keyword.</P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN191"
>The 'This' special type.</A
></H3
><P
>In the Java language as in ooc, you have the
          <TT
CLASS="literal"
>this</TT
> keyword, to refer to the current instance of
          the object we're defining a function of, e.g.:</P
><PRE
CLASS="programlisting"
>class Color {

  Float r, g, b;

  func compare(Float r) {
    if(r != this.r) {
      printf("different !\n");
    }
  }

}</PRE
><P
>ooc extends this concept and introduce the
          <TT
CLASS="literal"
>This</TT
> type, which refers to the type of the class
          we're defining:</P
><PRE
CLASS="programlisting"
>class Vector {

  Float x, y, z;

  // only allow adding with vectors of the same type.
  func add(This v2) {
    x += v2.x;
    y += v2.y;
    z += v2.z;
  }

}</PRE
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN199"
>Covers</A
></H2
><P
>A cover is a set of functions added to a primitive type. For
        example, String is a typedef to char*, and it has a cover
        (<TT
CLASS="literal"
>lang.String</TT
>), which adds functions
        <TT
CLASS="literal"
>length</TT
>, <TT
CLASS="literal"
>equals</TT
>,
        <TT
CLASS="literal"
>startsWith</TT
>, etc. Covers are low-level constructs
        with a high-level syntax, which makes them very useful in
        performance-critical environments.</P
><PRE
CLASS="programlisting"
>include stdio;

typedef Char* String;

cover String {

  func print {
    puts(this);
  }

}

func main {

  String s = "Hello world!";
  s.print;

}
</PRE
><P
>Difference between class and covers will be treated more in
        depth in <A
HREF="c278.htm"
>a next chapter</A
>.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN68"
HREF="c31.htm#AEN68"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This may raise a concern: what about name collision? In
              practice, this is almost never a problem with ooc. The generated
              C code is always prefixed with a few underscores '_' and the
              package and source unit name. E.g.
              __my_app_MyUnit_CONSTANT</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"/><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="f16.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x209.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Preface</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Arrays</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>